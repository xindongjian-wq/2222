<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2.5D ç­‰è·åœºæ™¯</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #fef7ed;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: system-ui, sans-serif;
    }
    .header {
      background: linear-gradient(90deg, #9333ea, #ec4899, #f97316);
      color: white;
      padding: 12px 24px;
      font-weight: bold;
      font-size: 14px;
      width: 100%;
      text-align: center;
      position: fixed;
      top: 0;
      z-index: 100;
    }
    .container {
      margin-top: 60px;
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      overflow: hidden;
      border: 2px solid #fed7aa;
    }
    canvas {
      display: block;
      cursor: grab;
    }
    canvas:active { cursor: grabbing; }
    .controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      gap: 8px;
      background: white;
      padding: 8px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .controls button {
      width: 40px;
      height: 40px;
      border: none;
      background: #f3f4f6;
      border-radius: 8px;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .controls button:hover { background: #e5e7eb; }
    .info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: white;
      padding: 12px 16px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      font-size: 12px;
      color: #6b7280;
    }
    .legend {
      position: fixed;
      top: 80px;
      right: 20px;
      background: white;
      padding: 12px 16px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      font-size: 12px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
    }
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div class="header">ğŸ† é¦–å±Š A2A é»‘å®¢æ¾ç«èµ›ç«çƒ­è¿›è¡Œä¸­</div>

  <div class="container">
    <canvas id="canvas" width="1200" height="700"></canvas>
  </div>

  <div class="legend">
    <div class="legend-item"><div class="legend-color" style="background:#d4a574"></div>å¹¿åœº</div>
    <div class="legend-item"><div class="legend-color" style="background:#7cb87c"></div>å•†åŸ</div>
    <div class="legend-item"><div class="legend-color" style="background:#a67db8"></div>å¤´è„‘é£æš´å®¤</div>
    <div class="legend-item"><div class="legend-color" style="background:#6b8cce"></div>å¤‡æˆ˜å®¤</div>
    <div class="legend-item"><div class="legend-color" style="background:#d4848c"></div>è¯„å®¡å®¤</div>
    <div class="legend-item"><div class="legend-color" style="background:#6bb8a8"></div>ä¼‘æ¯åŒº</div>
    <div class="legend-item"><div class="legend-color" style="background:#7a8cbd"></div>å®éªŒå®¤</div>
  </div>

  <div class="controls">
    <button onclick="zoomIn()">+</button>
    <button onclick="zoomOut()">âˆ’</button>
    <button onclick="resetView()">âŸ²</button>
  </div>

  <div class="info">
    æ»šè½®ç¼©æ”¾ â€¢ æ‹–æ‹½å¹³ç§» â€¢ ç‚¹å‡»è§’è‰²æŸ¥çœ‹ä¿¡æ¯
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // é…ç½®
    const HEX_SIZE = 32;
    const HEX_DEPTH = 10;

    // è§†å›¾çŠ¶æ€
    let scale = 1;
    let panX = 0;
    let panY = 0;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;

    // åŒºåŸŸé…ç½®
    const ZONES = [
      { id: 'plaza', name: 'å¹¿åœº', color: '#d4a574', q: 0, r: 0, type: 'large' },
      { id: 'shop', name: 'å•†åŸ', color: '#7cb87c', q: 5, r: -3, type: 'small' },
      { id: 'brainstorm', name: 'å¤´è„‘é£æš´å®¤', color: '#a67db8', q: 5, r: 3, type: 'small' },
      { id: 'readyRoom', name: 'å¤‡æˆ˜å®¤', color: '#6b8cce', q: 0, r: 5, type: 'small' },
      { id: 'review', name: 'è¯„å®¡å®¤', color: '#d4848c', q: -5, r: 3, type: 'small' },
      { id: 'restArea', name: 'ä¼‘æ¯åŒº', color: '#6bb8a8', q: -5, r: -3, type: 'small' },
      { id: 'lab', name: 'å®éªŒå®¤', color: '#7a8cbd', q: 0, r: -5, type: 'small' },
    ];

    // è§’è‰²
    const CHARACTERS = [
      { id: '1', name: 'Alice', skill: 'å‰ç«¯', color: '#48bb78', q: 0, r: 0, zone: 'plaza' },
      { id: '2', name: 'Bob', skill: 'åç«¯', color: '#4299e1', q: 5, r: -3, zone: 'shop' },
      { id: '3', name: 'Carol', skill: 'è®¾è®¡', color: '#ed64a6', q: 5, r: 3, zone: 'brainstorm' },
      { id: '4', name: 'Dave', skill: 'å…¨æ ˆ', color: '#ecc94b', q: 0, r: 5, zone: 'readyRoom' },
      { id: '5', name: 'Eve', skill: 'PM', color: '#9f7aea', q: -5, r: 3, zone: 'review' },
      { id: '6', name: 'Frank', skill: 'AI', color: '#f56565', q: -5, r: -3, zone: 'restArea' },
      { id: '7', name: 'Grace', skill: 'è¿ç»´', color: '#38b2ac', q: 0, r: -5, zone: 'lab' },
    ];

    // è½´å‘åæ ‡è½¬å±å¹•åæ ‡
    function axialToScreen(q, r) {
      const x = HEX_SIZE * Math.sqrt(3) * (q + r / 2);
      const y = HEX_SIZE * 1.5 * r;
      return { x, y };
    }

    // é¢œè‰²è°ƒæ•´
    function shadeColor(color, percent) {
      const num = parseInt(color.replace('#', ''), 16);
      const amt = Math.round(2.55 * percent);
      const R = Math.min(255, Math.max(0, (num >> 16) + amt));
      const G = Math.min(255, Math.max(0, (num >> 8 & 0x00FF) + amt));
      const B = Math.min(255, Math.max(0, (num & 0x0000FF) + amt));
      return '#' + ((1 << 24) + (R << 16) + (G << 8) + B).toString(16).slice(1);
    }

    // è·å–å…­è¾¹å½¢é¡¶ç‚¹
    function getHexVertices(cx, cy, size) {
      const angles = [-Math.PI/2, -Math.PI/6, Math.PI/6, Math.PI/2, 5*Math.PI/6, 7*Math.PI/6];
      return angles.map(a => ({
        x: cx + size * Math.cos(a),
        y: cy + size * Math.sin(a)
      }));
    }

    // ç»˜åˆ¶å…­è¾¹å½¢ç“¦ç‰‡
    function drawHexTile(q, r, color) {
      const screen = axialToScreen(q, r);
      const v = getHexVertices(screen.x, screen.y, HEX_SIZE);

      // é˜´å½±
      ctx.fillStyle = 'rgba(0,0,0,0.1)';
      ctx.beginPath();
      ctx.moveTo(v[0].x + 3, v[0].y + HEX_DEPTH + 3);
      for (let i = 1; i < 6; i++) ctx.lineTo(v[i].x + 3, v[i].y + HEX_DEPTH + 3);
      ctx.closePath();
      ctx.fill();

      // å·¦ä¾§é¢
      ctx.fillStyle = shadeColor(color, -15);
      ctx.beginPath();
      ctx.moveTo(v[3].x, v[3].y);
      ctx.lineTo(v[4].x, v[4].y);
      ctx.lineTo(v[4].x, v[4].y + HEX_DEPTH);
      ctx.lineTo(v[3].x, v[3].y + HEX_DEPTH);
      ctx.closePath();
      ctx.fill();

      // å³ä¾§é¢
      ctx.fillStyle = shadeColor(color, -30);
      ctx.beginPath();
      ctx.moveTo(v[4].x, v[4].y);
      ctx.lineTo(v[5].x, v[5].y);
      ctx.lineTo(v[5].x, v[5].y + HEX_DEPTH);
      ctx.lineTo(v[4].x, v[4].y + HEX_DEPTH);
      ctx.closePath();
      ctx.fill();

      // åº•é¢
      ctx.fillStyle = shadeColor(color, -40);
      ctx.beginPath();
      ctx.moveTo(v[5].x, v[5].y);
      ctx.lineTo(v[0].x, v[0].y);
      ctx.lineTo(v[0].x, v[0].y + HEX_DEPTH);
      ctx.lineTo(v[5].x, v[5].y + HEX_DEPTH);
      ctx.closePath();
      ctx.fill();

      // é¡¶é¢
      ctx.fillStyle = shadeColor(color, 10);
      ctx.beginPath();
      ctx.moveTo(v[0].x, v[0].y);
      for (let i = 1; i < 6; i++) ctx.lineTo(v[i].x, v[i].y);
      ctx.closePath();
      ctx.fill();
    }

    // è·å–å¤§å…­è¾¹å½¢æ ¼å­
    function getLargeHexTiles(cq, cr, radius) {
      const tiles = [];
      for (let q = -radius; q <= radius; q++) {
        const r1 = Math.max(-radius, -q - radius);
        const r2 = Math.min(radius, -q + radius);
        for (let r = r1; r <= r2; r++) {
          tiles.push({ q: cq + q, r: cr + r });
        }
      }
      return tiles;
    }

    // è·å–å°å…­è¾¹å½¢åŒºåŸŸ (3,4,5,4,3 æ’åˆ—)
    function getSmallHexTiles(cq, cr) {
      const tiles = [];
      const rowPattern = [3, 4, 5, 4, 3];
      rowPattern.forEach((count, rowIdx) => {
        const rowOffset = rowIdx - 2;
        const startCol = Math.floor((5 - count) / 2);
        for (let col = 0; col < count; col++) {
          const localQ = startCol + col - 2;
          tiles.push({ q: cq + localQ, r: cr + rowOffset });
        }
      });
      return tiles;
    }

    // ç»˜åˆ¶è¾¹ç•Œçº¿
    function drawBoundary(tiles, color) {
      const tileSet = new Set(tiles.map(t => `${t.q},${t.r}`));
      const directions = [
        { q: 1, r: 0 }, { q: 1, r: -1 }, { q: 0, r: -1 },
        { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 }
      ];
      const edgeIndices = [[0,1], [1,2], [2,3], [3,4], [4,5], [5,0]];
      const angles = [-Math.PI/2, -Math.PI/6, Math.PI/6, Math.PI/2, 5*Math.PI/6, 7*Math.PI/6];

      tiles.forEach(t => {
        directions.forEach((dir, i) => {
          const n = { q: t.q + dir.q, r: t.r + dir.r };
          if (!tileSet.has(`${n.q},${n.r}`)) {
            const screen = axialToScreen(t.q, t.r);
            const [i1, i2] = edgeIndices[i];
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.shadowColor = color;
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.moveTo(screen.x + HEX_SIZE * Math.cos(angles[i1]), screen.y + HEX_SIZE * Math.sin(angles[i1]));
            ctx.lineTo(screen.x + HEX_SIZE * Math.cos(angles[i2]), screen.y + HEX_SIZE * Math.sin(angles[i2]));
            ctx.stroke();
            ctx.shadowBlur = 0;
          }
        });
      });
    }

    // ç»˜åˆ¶åŒºåŸŸåç§°
    function drawZoneLabel(q, r, name, color) {
      const screen = axialToScreen(q, r);
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      const w = ctx.measureText(name).width + 16;
      ctx.fillRect(screen.x - w/2, screen.y - 22, w, 18);
      ctx.fillStyle = color;
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.shadowColor = color;
      ctx.shadowBlur = 6;
      ctx.fillText(name, screen.x, screen.y - 9);
      ctx.shadowBlur = 0;
    }

    // ç»˜åˆ¶è§’è‰²
    function drawCharacter(char, time) {
      const screen = axialToScreen(char.q, char.r);
      const bounce = Math.sin(time * 0.003 + char.id.charCodeAt(0)) * 2;
      const baseY = screen.y - 12 + bounce;

      // é˜´å½±
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.beginPath();
      ctx.ellipse(screen.x, screen.y + 2, 7, 3, 0, 0, Math.PI * 2);
      ctx.fill();

      // èº«ä½“
      ctx.fillStyle = char.color;
      ctx.shadowColor = char.color;
      ctx.shadowBlur = 8;
      ctx.fillRect(screen.x - 5, baseY - 10, 10, 12);
      ctx.fillRect(screen.x - 4, baseY - 18, 8, 8);
      ctx.shadowBlur = 0;

      // çœ¼ç›
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(screen.x - 1.5, baseY - 14, 1.5, 0, Math.PI * 2);
      ctx.arc(screen.x + 1.5, baseY - 14, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // å¤©çº¿
      ctx.strokeStyle = char.color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(screen.x, baseY - 18);
      ctx.lineTo(screen.x, baseY - 24);
      ctx.stroke();
      ctx.fillStyle = '#fef08a';
      ctx.beginPath();
      ctx.arc(screen.x, baseY - 24, 2.5, 0, Math.PI * 2);
      ctx.fill();

      // åç§°
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      const nw = ctx.measureText(char.name).width + 8;
      ctx.fillRect(screen.x - nw/2, baseY - 36, nw, 12);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 9px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(char.name, screen.x, baseY - 27);
    }

    // ä¼ é€é—¨åŠ¨ç”»æ—¶é—´
    let animTime = 0;

    // ä¸»æ¸²æŸ“
    function render() {
      animTime += 16;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();

      // ç§»åŠ¨åˆ°ä¸­å¿ƒå¹¶åº”ç”¨å˜æ¢
      ctx.translate(canvas.width / 2 + panX, canvas.height / 2 + panY);
      ctx.scale(scale, scale);

      // ç»˜åˆ¶èƒŒæ™¯
      ctx.fillStyle = '#fef7ed';
      ctx.fillRect(-600, -400, 1200, 800);

      // æ”¶é›†æ‰€æœ‰å…ƒç´ ç”¨äºæ’åº
      const renderItems = [];

      // ç»˜åˆ¶åŒºåŸŸç“¦ç‰‡
      ZONES.forEach(zone => {
        const tiles = zone.type === 'large'
          ? getLargeHexTiles(zone.q, zone.r, 3)
          : getSmallHexTiles(zone.q, zone.r);

        tiles.forEach(t => {
          const screen = axialToScreen(t.q, t.r);
          renderItems.push({ y: screen.y, type: 'tile', data: { ...t, color: zone.color } });
        });
      });

      // æŒ‰Yåæ ‡æ’åº
      renderItems.sort((a, b) => a.y - b.y);

      // ç»˜åˆ¶ç“¦ç‰‡
      renderItems.forEach(item => {
        if (item.type === 'tile') {
          drawHexTile(item.data.q, item.data.r, item.data.color);
        }
      });

      // ç»˜åˆ¶è¾¹ç•Œå’Œæ ‡ç­¾
      ZONES.forEach(zone => {
        const tiles = zone.type === 'large'
          ? getLargeHexTiles(zone.q, zone.r, 3)
          : getSmallHexTiles(zone.q, zone.r);
        drawBoundary(tiles, zone.color);
        drawZoneLabel(zone.q, zone.r, zone.name, zone.color);
      });

      // ç»˜åˆ¶è§’è‰²
      CHARACTERS.forEach(char => drawCharacter(char, animTime));

      ctx.restore();
      requestAnimationFrame(render);
    }

    // äº‹ä»¶å¤„ç†
    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      scale = Math.max(0.4, Math.min(2, scale + (e.deltaY > 0 ? -0.1 : 0.1)));
    });

    canvas.addEventListener('mousedown', e => {
      isDragging = true;
      dragStartX = e.clientX - panX;
      dragStartY = e.clientY - panY;
    });

    canvas.addEventListener('mousemove', e => {
      if (isDragging) {
        panX = e.clientX - dragStartX;
        panY = e.clientY - dragStartY;
      }
    });

    canvas.addEventListener('mouseup', () => isDragging = false);
    canvas.addEventListener('mouseleave', () => isDragging = false);

    // ç‚¹å‡»æ£€æµ‹è§’è‰²
    canvas.addEventListener('click', e => {
      if (isDragging) return;
      const rect = canvas.getBoundingClientRect();
      const clickX = (e.clientX - rect.left - canvas.width/2 - panX) / scale;
      const clickY = (e.clientY - rect.top - canvas.height/2 - panY) / scale;

      CHARACTERS.forEach(char => {
        const screen = axialToScreen(char.q, char.r);
        const dist = Math.sqrt((clickX - screen.x) ** 2 + (clickY - (screen.y - 10)) ** 2);
        if (dist < 20) {
          alert(`${char.name} - ${char.skill}\næŠ€èƒ½: ${char.skill}\nç‚¹å‡»è¿æ¥ä¸»äºº`);
        }
      });
    });

    // æ§åˆ¶æŒ‰é’®
    function zoomIn() { scale = Math.min(2, scale + 0.15); }
    function zoomOut() { scale = Math.max(0.4, scale - 0.15); }
    function resetView() { scale = 1; panX = 0; panY = 0; }

    // å¯åŠ¨æ¸²æŸ“
    render();
  </script>
</body>
</html>
